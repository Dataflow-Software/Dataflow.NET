// Generated By Dataflow implementation of Protocol Buffers to C# compiler

using System;
using Dataflow.Core;

namespace Dataflow.Tests
{
	// package: Dataflow.Tests
	
	public enum Colors
	{
		Red = 1, Green = 2, Blue = 3
	}
	
	public static partial class EnumDescriptors
	{
		public static readonly EnumDescriptor Colors = new EnumDescriptor( "Colors",
			new EnumFieldDescriptor("Red", 1),
			new EnumFieldDescriptor("Green", 2),
			new EnumFieldDescriptor("Blue", 3)
		);
	}
	
	public sealed partial class Int32Value : Message
	{
		public override MessageDescriptor GetDescriptor() { return Descriptor; }
		public static readonly MessageDescriptor Descriptor = new MessageDescriptor_20( "Int32Value", Pbs.iBox,
			new Int32Value(),
			new FieldDescriptor("Value", 8, 1)
		);
		// bit-masks for tracking value type fields nulls.
		private int _b0;
		
		// optional int32 Value = 1;
		public int Value { get { return _value; } set { _b0|=0x01; _value= value; } }
		
		#region message fields
		private int _value;
		public void ClearValue() { _b0&=~0x01; _value = 0; }
		public bool HasValue { get { return (_b0&0x01) != 0; } }
		#endregion
		
		#region message methods
		public Int32Value() {}
		public Int32Value( int value ) { Value = value; }
		public override Message New() { return new Int32Value(); }
		public override void Clear()
		{
			_memoized_size = _b0 = 0;
			_value = 0;
		}
		public override int GetHashCode() { return base.GetHashCode(); }
		public override bool Equals(object msg)
		{
			var test = msg as Int32Value;
			if(test==null) return false;
			if(Value != test.Value) return false;
			return true;
		}
		public override void Get(FieldDescriptor ds_, IDataReader dr_)
		{
			Value = dr_.AsInt();
		}
		public override int GetSerializedSize()
		{
			 return !HasValue ? 0 : 1 + Pbs.i32(_value);
		}
		public override void Put(IDataWriter wr_)
		{
			var fs_ = Descriptor.Fields;
			if(HasValue) wr_.AsInt(fs_[0], _value);
		}
		#endregion
	}
	
	public sealed partial class Case : Message
	{
		public override MessageDescriptor GetDescriptor() { return Descriptor; }
		public static readonly MessageDescriptor Descriptor = new MessageDescriptor_20( "Case", Pbs.iBox,
			new Case(),
			new FieldDescriptor("Name", 26, 5)
		);
		// bit-masks for tracking value type fields nulls.
		private int _b0;
		
		// optional string Name = 3;
		public string Name { get { return _name; } set { _b0|=0x01; _name= value; } }
		
		#region message fields
		private string _name;
		public void ClearName() { _b0&=~0x01; _name = "abc"; }
		public bool HasName { get { return (_b0&0x01) != 0; } }
		#endregion
		
		#region message methods
		public Case() {}
		public Case( string value ) { Name = value; }
		public override Message New() { return new Case(); }
		public override void Clear()
		{
			_memoized_size = _b0 = 0;
			_name = "abc";
		}
		public override int GetHashCode() { return base.GetHashCode(); }
		public override bool Equals(object msg)
		{
			var test = msg as Case;
			if(test==null) return false;
			if(Name != test.Name) return false;
			return true;
		}
		public override void Get(FieldDescriptor ds_, IDataReader dr_)
		{
			Name = dr_.AsString();
		}
		public override int GetSerializedSize()
		{
			 return !HasName ? 0 : 1 + Pbs.str(_name);
		}
		public override void Put(IDataWriter wr_)
		{
			var fs_ = Descriptor.Fields;
			if(HasName) wr_.AsString(fs_[0], _name);
		}
		#endregion
	}
	
	public sealed partial class OptFields : Message
	{
		public override MessageDescriptor GetDescriptor() { return Descriptor; }
		public static readonly MessageDescriptor Descriptor = new MessageDescriptor_20( "OptFields", Pbs.iNone,
			new OptFields(),
			new FieldDescriptor("I32", 8, 1),
			new FieldDescriptor("I64", 16, 2),
			new FieldDescriptor("Str", 26, 5),
			new FieldDescriptor("Bts", 34, 6),
			new FieldDescriptor("Bln", 40, 13),
			new FieldDescriptor("Flt", 53, 11),
			new FieldDescriptor("Cur", 56, 17),
			new FieldDescriptor("Dbl", 65, 12),
			new FieldDescriptor("Dat", 72, 7),
			new FieldDescriptor("Si32", 80, 1025),
			new FieldDescriptor("Si64", 88, 1026),
			new FieldDescriptor("Ui32", 96, 1),
			new FieldDescriptor("Ui64", 104, 2),
			new FieldDescriptor("Dec", 114, 8),
			new FieldDescriptor("Chr", 120, 14),
			new FieldDescriptor("Enu", 128, 16, EnumDescriptors.Colors),
			new FieldDescriptor("F32", 141, 9),
			new FieldDescriptor("F64", 145, 10)
		);
		// bit-masks for tracking value type fields nulls.
		private int _b0;
		
		// optional int32 I32 = 1;
		public int I32 { get { return _i32; } set { _b0|=0x01; _i32= value; } }
		// optional int64 I64 = 2;
		public long I64 { get { return _i64; } set { _b0|=0x02; _i64= value; } }
		// optional string Str = 3;
		public string Str { get; set; }
		// optional bytes Bts = 4;
		public byte[] Bts { get; set; }
		// optional bool Bln = 5;
		public bool Bln { get { return _bln; } set { _b0|=0x04; _bln= value; } }
		// optional float Flt = 6;
		public float Flt { get { return _flt; } set { _b0|=0x08; _flt= value; } }
		// optional currency Cur = 7;
		public Currency Cur { get { return _cur; } set { _b0|=0x10; _cur= value; } }
		// optional double Dbl = 8;
		public double Dbl { get { return _dbl; } set { _b0|=0x20; _dbl= value; } }
		// optional datetime Dat = 9;
		public DateTime Dat { get { return _dat; } set { _b0|=0x40; _dat= value; } }
		// optional sint32 Si32 = 10;
		public int Si32 { get { return _si32; } set { _b0|=0x80; _si32= value; } }
		// optional sint64 Si64 = 11;
		public long Si64 { get { return _si64; } set { _b0|=0x0100; _si64= value; } }
		// optional uint32 Ui32 = 12;
		public uint Ui32 { get { return _ui32; } set { _b0|=0x0200; _ui32= value; } }
		// optional uint64 Ui64 = 13;
		public ulong Ui64 { get { return _ui64; } set { _b0|=0x0400; _ui64= value; } }
		// optional decimal Dec = 14;
		public decimal Dec { get { return _dec; } set { _b0|=0x0800; _dec= value; } }
		// optional char Chr = 15;
		public char Chr { get { return _chr; } set { _b0|=0x1000; _chr= value; } }
		// optional Colors Enu = 16;
		public Colors Enu { get { return _enu; } set { _b0|=0x2000; _enu= value; } }
		// optional fixed32 F32 = 17;
		public uint F32 { get { return _f32; } set { _b0|=0x4000; _f32= value; } }
		// optional fixed64 F64 = 18;
		public ulong F64 { get { return _f64; } set { _b0|=0x8000; _f64= value; } }
		
		#region message fields
		private int _i32;
		public void ClearI32() { _b0&=~0x01; _i32 = 25; }
		public bool HasI32 { get { return (_b0&0x01) != 0; } }
		private long _i64;
		public void ClearI64() { _b0&=~0x02; _i64 = 0; }
		public bool HasI64 { get { return (_b0&0x02) != 0; } }
		public void ClearStr() { Str = null; }
		public bool HasStr { get { return Str != null; } }
		public void ClearBts() { Bts = null; }
		public bool HasBts { get { return Bts != null; } }
		private bool _bln;
		public void ClearBln() { _b0&=~0x04; _bln = false; }
		public bool HasBln { get { return (_b0&0x04) != 0; } }
		private float _flt;
		public void ClearFlt() { _b0&=~0x08; _flt = 0; }
		public bool HasFlt { get { return (_b0&0x08) != 0; } }
		private Currency _cur;
		public void ClearCur() { _b0&=~0x10; _cur = Currency.Zero; }
		public bool HasCur { get { return (_b0&0x10) != 0; } }
		private double _dbl;
		public void ClearDbl() { _b0&=~0x20; _dbl = 0; }
		public bool HasDbl { get { return (_b0&0x20) != 0; } }
		private DateTime _dat;
		public void ClearDat() { _b0&=~0x40; _dat = DateTime.MinValue; }
		public bool HasDat { get { return (_b0&0x40) != 0; } }
		private int _si32;
		public void ClearSi32() { _b0&=~0x80; _si32 = 0; }
		public bool HasSi32 { get { return (_b0&0x80) != 0; } }
		private long _si64;
		public void ClearSi64() { _b0&=~0x0100; _si64 = 0; }
		public bool HasSi64 { get { return (_b0&0x0100) != 0; } }
		private uint _ui32;
		public void ClearUi32() { _b0&=~0x0200; _ui32 = 0; }
		public bool HasUi32 { get { return (_b0&0x0200) != 0; } }
		private ulong _ui64;
		public void ClearUi64() { _b0&=~0x0400; _ui64 = 0; }
		public bool HasUi64 { get { return (_b0&0x0400) != 0; } }
		private decimal _dec;
		public void ClearDec() { _b0&=~0x0800; _dec = Decimal.Zero; }
		public bool HasDec { get { return (_b0&0x0800) != 0; } }
		private char _chr;
		public void ClearChr() { _b0&=~0x1000; _chr = '\0'; }
		public bool HasChr { get { return (_b0&0x1000) != 0; } }
		private Colors _enu;
		public void ClearEnu() { _b0&=~0x2000; _enu = Colors.Red; }
		public bool HasEnu { get { return (_b0&0x2000) != 0; } }
		private uint _f32;
		public void ClearF32() { _b0&=~0x4000; _f32 = 0; }
		public bool HasF32 { get { return (_b0&0x4000) != 0; } }
		private ulong _f64;
		public void ClearF64() { _b0&=~0x8000; _f64 = 0; }
		public bool HasF64 { get { return (_b0&0x8000) != 0; } }
		#endregion
		
		#region message methods
		public OptFields()
		{
			_i32 = 25;
			_enu = Colors.Red;
		}
		public override Message New() { return new OptFields(); }
		public override void Clear()
		{
			_memoized_size = _b0 = 0;
			_i32 = 25;
			_i64 = 0;
			Str = null;
			Bts = null;
			_bln = false;
			_flt = 0;
			_cur = Currency.Zero;
			_dbl = 0;
			_dat = DateTime.MinValue;
			_si32 = 0;
			_si64 = 0;
			_ui32 = 0;
			_ui64 = 0;
			_dec = Decimal.Zero;
			_chr = '\0';
			_enu = Colors.Red;
			_f32 = 0;
			_f64 = 0;
		}
		public override int GetHashCode() { return base.GetHashCode(); }
		public override bool Equals(object msg)
		{
			var test = msg as OptFields;
			if(test==null) return false;
			if(I32 != test.I32) return false;
			if(I64 != test.I64) return false;
			if(Str != test.Str) return false;
			if(!Pbs.EqualBytes(Bts,test.Bts)) return false;
			if(Bln != test.Bln) return false;
			if(Flt != test.Flt) return false;
			if(Cur != test.Cur) return false;
			if(Dbl != test.Dbl) return false;
			if(Dat != test.Dat) return false;
			if(Si32 != test.Si32) return false;
			if(Si64 != test.Si64) return false;
			if(Ui32 != test.Ui32) return false;
			if(Ui64 != test.Ui64) return false;
			if(Dec != test.Dec) return false;
			if(Chr != test.Chr) return false;
			if(Enu != test.Enu) return false;
			if(F32 != test.F32) return false;
			if(F64 != test.F64) return false;
			return true;
		}
		public override void Get(FieldDescriptor ds_, IDataReader dr_)
		{
			switch( ds_.Pos )
			{
				case 0: I32 = dr_.AsInt(); break;
				case 1: I64 = dr_.AsLong(); break;
				case 2: Str = dr_.AsString(); break;
				case 3: Bts = dr_.AsBytes(); break;
				case 4: Bln = dr_.AsBool(); break;
				case 5: Flt = dr_.AsFloat(); break;
				case 6: Cur = dr_.AsCurrency(); break;
				case 7: Dbl = dr_.AsDouble(); break;
				case 8: Dat = dr_.AsDate(); break;
				case 9: Si32 = dr_.AsSi32(); break;
				case 10: Si64 = dr_.AsSi64(); break;
				case 11: Ui32 = (uint)dr_.AsInt(); break;
				case 12: Ui64 = (ulong)dr_.AsLong(); break;
				case 13: Dec = dr_.AsDecimal(); break;
				case 14: Chr = dr_.AsChar(); break;
				case 15: Enu = (Colors)dr_.AsEnum(EnumDescriptors.Colors); break;
				case 16: F32 = (uint)dr_.AsBit32(); break;
				case 17: F64 = (ulong)dr_.AsBit64(); break;
			}
		}
		public override int GetSerializedSize()
		{
			var _gss_ = 0;
			if(HasI32) _gss_ += 1 + Pbs.i32(_i32);
			if(HasI64) _gss_ += 1 + Pbs.i64(_i64);
			if(HasStr) _gss_ += 1 + Pbs.str(Str);
			if(HasBts) _gss_ += 1 + Pbs.bts(Bts);
			if(HasBln) _gss_ += 2;
			if(HasFlt) _gss_ += 5;
			if(HasCur) _gss_ += 1 + Pbs.cur(_cur);
			if(HasDbl) _gss_ += 9;
			if(HasDat) _gss_ += 1 + Pbs.dat(_dat);
			if(HasSi32) _gss_ += 1 + Pbs.si32(_si32);
			if(HasSi64) _gss_ += 1 + Pbs.si64(_si64);
			if(HasUi32) _gss_ += 1 + Pbs.i32((int)_ui32);
			if(HasUi64) _gss_ += 1 + Pbs.i64((long)_ui64);
			if(HasDec) _gss_ += 1 + Pbs.dec(_dec);
			if(HasChr) _gss_ += 1 + Pbs.chr(_chr);
			if(HasEnu) _gss_ += 3;
			if(HasF32) _gss_ += 6;
			if(HasF64) _gss_ += 10;
			return _memoized_size = _gss_;
		}
		public override void Put(IDataWriter wr_)
		{
			var fs_ = Descriptor.Fields;
			if(HasI32) wr_.AsInt(fs_[0], _i32);
			if(HasI64) wr_.AsLong(fs_[1], _i64);
			if(HasStr) wr_.AsString(fs_[2], Str);
			if(HasBts) wr_.AsBytes(fs_[3], Bts);
			if(HasBln) wr_.AsBool(fs_[4], _bln);
			if(HasFlt) wr_.AsFloat(fs_[5], _flt);
			if(HasCur) wr_.AsCurrency(fs_[6], _cur);
			if(HasDbl) wr_.AsDouble(fs_[7], _dbl);
			if(HasDat) wr_.AsDate(fs_[8], _dat);
			if(HasSi32) wr_.AsSi32(fs_[9], _si32);
			if(HasSi64) wr_.AsSi64(fs_[10], _si64);
			if(HasUi32) wr_.AsInt(fs_[11], (int)_ui32);
			if(HasUi64) wr_.AsLong(fs_[12], (long)_ui64);
			if(HasDec) wr_.AsDecimal(fs_[13], _dec);
			if(HasChr) wr_.AsChar(fs_[14], _chr);
			if(HasEnu) wr_.AsEnum(fs_[15], (int)_enu);
			if(HasF32) wr_.AsBit32(fs_[16], (int)_f32);
			if(HasF64) wr_.AsBit64(fs_[17], (long)_f64);
		}
		#endregion
	}
	
	public sealed partial class RepFields : Message
	{
		public override MessageDescriptor GetDescriptor() { return Descriptor; }
		public static readonly MessageDescriptor Descriptor = new MessageDescriptor_20( "RepFields", Pbs.iNone,
			new RepFields(),
			new FieldDescriptor("I32", 8, 65),
			new FieldDescriptor("I64", 16, 66),
			new FieldDescriptor("Str", 26, 69),
			new FieldDescriptor("Bts", 34, 70),
			new FieldDescriptor("Bln", 40, 77),
			new FieldDescriptor("Flt", 53, 75),
			new FieldDescriptor("Cur", 56, 81),
			new FieldDescriptor("Dbl", 65, 332),
			new FieldDescriptor("Dat", 72, 71),
			new FieldDescriptor("Si32", 80, 1345),
			new FieldDescriptor("Si64", 88, 1090),
			new FieldDescriptor("Ui32", 96, 65),
			new FieldDescriptor("Ui64", 104, 66),
			new FieldDescriptor("Dec", 114, 72),
			new FieldDescriptor("Chr", 120, 78),
			new FieldDescriptor("Enu", 128, 336, EnumDescriptors.Colors),
			new FieldDescriptor("F32", 141, 73),
			new FieldDescriptor("F64", 145, 74)
		);
		
		// repeated int32 I32 = 1;
		public int[] I32 { get { return _i32.Items; } set { _i32.Items = value; } }
		// repeated int64 I64 = 2;
		public long[] I64 { get { return _i64.Items; } set { _i64.Items = value; } }
		// repeated string Str = 3;
		public string[] Str { get { return _str.Items; } set { _str.Items = value; } }
		// repeated bytes Bts = 4;
		public byte[][] Bts { get { return _bts.Items; } set { _bts.Items = value; } }
		// repeated bool Bln = 5;
		public bool[] Bln { get { return _bln.Items; } set { _bln.Items = value; } }
		// repeated float Flt = 6;
		public float[] Flt { get { return _flt.Items; } set { _flt.Items = value; } }
		// repeated currency Cur = 7;
		public Currency[] Cur { get { return _cur.Items; } set { _cur.Items = value; } }
		// repeated double Dbl = 8;
		public double[] Dbl { get { return _dbl.Items; } set { _dbl.Items = value; } }
		// repeated datetime Dat = 9;
		public DateTime[] Dat { get { return _dat.Items; } set { _dat.Items = value; } }
		// repeated sint32 Si32 = 10;
		public int[] Si32 { get { return _si32.Items; } set { _si32.Items = value; } }
		// repeated sint64 Si64 = 11;
		public long[] Si64 { get { return _si64.Items; } set { _si64.Items = value; } }
		// repeated uint32 Ui32 = 12;
		public uint[] Ui32 { get { return _ui32.Items; } set { _ui32.Items = value; } }
		// repeated uint64 Ui64 = 13;
		public ulong[] Ui64 { get { return _ui64.Items; } set { _ui64.Items = value; } }
		// repeated decimal Dec = 14;
		public decimal[] Dec { get { return _dec.Items; } set { _dec.Items = value; } }
		// repeated char Chr = 15;
		public char[] Chr { get { return _chr.Items; } set { _chr.Items = value; } }
		// repeated Colors Enu = 16;
		public Colors[] Enu { get { return _enu.Items; } set { _enu.Items = value; } }
		// repeated fixed32 F32 = 17;
		public uint[] F32 { get { return _f32.Items; } set { _f32.Items = value; } }
		// repeated fixed64 F64 = 18;
		public ulong[] F64 { get { return _f64.Items; } set { _f64.Items = value; } }
		
		#region message fields
		private Repeated<int> _i32;
		public int I32Count { get { return _i32.Count; } }
		public void ClearI32() { _i32.Clear(); }
		public int AddI32(int i) { return _i32.Add(i); }
		public int GetI32(int i) { return _i32[i]; }
		private Repeated<long> _i64;
		public int I64Count { get { return _i64.Count; } }
		public void ClearI64() { _i64.Clear(); }
		public long AddI64(long i) { return _i64.Add(i); }
		public long GetI64(int i) { return _i64[i]; }
		private Repeated<string> _str;
		public int StrCount { get { return _str.Count; } }
		public void ClearStr() { _str.Clear(); }
		public string AddStr(string i) { return _str.Add(i); }
		public string GetStr(int i) { return _str[i]; }
		private Repeated<byte[]> _bts;
		public int BtsCount { get { return _bts.Count; } }
		public void ClearBts() { _bts.Clear(); }
		public byte[] AddBts(byte[] i) { return _bts.Add(i); }
		public byte[] GetBts(int i) { return _bts[i]; }
		private Repeated<bool> _bln;
		public int BlnCount { get { return _bln.Count; } }
		public void ClearBln() { _bln.Clear(); }
		public bool AddBln(bool i) { return _bln.Add(i); }
		public bool GetBln(int i) { return _bln[i]; }
		private Repeated<float> _flt;
		public int FltCount { get { return _flt.Count; } }
		public void ClearFlt() { _flt.Clear(); }
		public float AddFlt(float i) { return _flt.Add(i); }
		public float GetFlt(int i) { return _flt[i]; }
		private Repeated<Currency> _cur;
		public int CurCount { get { return _cur.Count; } }
		public void ClearCur() { _cur.Clear(); }
		public Currency AddCur(Currency i) { return _cur.Add(i); }
		public Currency GetCur(int i) { return _cur[i]; }
		private Repeated<double> _dbl;
		public int DblCount { get { return _dbl.Count; } }
		public void ClearDbl() { _dbl.Clear(); }
		public double AddDbl(double i) { return _dbl.Add(i); }
		public double GetDbl(int i) { return _dbl[i]; }
		private Repeated<DateTime> _dat;
		public int DatCount { get { return _dat.Count; } }
		public void ClearDat() { _dat.Clear(); }
		public DateTime AddDat(DateTime i) { return _dat.Add(i); }
		public DateTime GetDat(int i) { return _dat[i]; }
		private Repeated<int> _si32;
		public int Si32Count { get { return _si32.Count; } }
		public void ClearSi32() { _si32.Clear(); }
		public int AddSi32(int i) { return _si32.Add(i); }
		public int GetSi32(int i) { return _si32[i]; }
		private Repeated<long> _si64;
		public int Si64Count { get { return _si64.Count; } }
		public void ClearSi64() { _si64.Clear(); }
		public long AddSi64(long i) { return _si64.Add(i); }
		public long GetSi64(int i) { return _si64[i]; }
		private Repeated<uint> _ui32;
		public int Ui32Count { get { return _ui32.Count; } }
		public void ClearUi32() { _ui32.Clear(); }
		public uint AddUi32(uint i) { return _ui32.Add(i); }
		public uint GetUi32(int i) { return _ui32[i]; }
		private Repeated<ulong> _ui64;
		public int Ui64Count { get { return _ui64.Count; } }
		public void ClearUi64() { _ui64.Clear(); }
		public ulong AddUi64(ulong i) { return _ui64.Add(i); }
		public ulong GetUi64(int i) { return _ui64[i]; }
		private Repeated<decimal> _dec;
		public int DecCount { get { return _dec.Count; } }
		public void ClearDec() { _dec.Clear(); }
		public decimal AddDec(decimal i) { return _dec.Add(i); }
		public decimal GetDec(int i) { return _dec[i]; }
		private Repeated<char> _chr;
		public int ChrCount { get { return _chr.Count; } }
		public void ClearChr() { _chr.Clear(); }
		public char AddChr(char i) { return _chr.Add(i); }
		public char GetChr(int i) { return _chr[i]; }
		private Repeated<Colors> _enu;
		public int EnuCount { get { return _enu.Count; } }
		public void ClearEnu() { _enu.Clear(); }
		public Colors AddEnu(Colors i) { return _enu.Add(i); }
		public Colors GetEnu(int i) { return _enu[i]; }
		private Repeated<uint> _f32;
		public int F32Count { get { return _f32.Count; } }
		public void ClearF32() { _f32.Clear(); }
		public uint AddF32(uint i) { return _f32.Add(i); }
		public uint GetF32(int i) { return _f32[i]; }
		private Repeated<ulong> _f64;
		public int F64Count { get { return _f64.Count; } }
		public void ClearF64() { _f64.Clear(); }
		public ulong AddF64(ulong i) { return _f64.Add(i); }
		public ulong GetF64(int i) { return _f64[i]; }
		#endregion
		
		#region message methods
		public override Message New() { return new RepFields(); }
		public override void Clear()
		{
			_memoized_size = 0;
			_i32.Clear();
			_i64.Clear();
			_str.Clear();
			_bts.Clear();
			_bln.Clear();
			_flt.Clear();
			_cur.Clear();
			_dbl.Clear();
			_dat.Clear();
			_si32.Clear();
			_si64.Clear();
			_ui32.Clear();
			_ui64.Clear();
			_dec.Clear();
			_chr.Clear();
			_enu.Clear();
			_f32.Clear();
			_f64.Clear();
		}
		public override int GetHashCode() { return base.GetHashCode(); }
		public override bool Equals(object msg)
		{
			var test = msg as RepFields;
			if(test==null) return false;
			if(_i32.Count != test._i32.Count) return false;
			for(var i = 0; i < _i32.Count; i++) if(_i32[i] != test._i32[i]) return false;
			if(_i64.Count != test._i64.Count) return false;
			for(var i = 0; i < _i64.Count; i++) if(_i64[i] != test._i64[i]) return false;
			if(_str.Count != test._str.Count) return false;
			for(var i = 0; i < _str.Count; i++) if(_str[i] != test._str[i]) return false;
			if(_bts.Count != test._bts.Count) return false;
			for(var i = 0; i < _bts.Count; i++) if(!Pbs.EqualBytes(_bts[i],test._bts[i])) return false;
			if(_bln.Count != test._bln.Count) return false;
			for(var i = 0; i < _bln.Count; i++) if(_bln[i] != test._bln[i]) return false;
			if(_flt.Count != test._flt.Count) return false;
			for(var i = 0; i < _flt.Count; i++) if(_flt[i] != test._flt[i]) return false;
			if(_cur.Count != test._cur.Count) return false;
			for(var i = 0; i < _cur.Count; i++) if(_cur[i] != test._cur[i]) return false;
			if(_dbl.Count != test._dbl.Count) return false;
			for(var i = 0; i < _dbl.Count; i++) if(_dbl[i] != test._dbl[i]) return false;
			if(_dat.Count != test._dat.Count) return false;
			for(var i = 0; i < _dat.Count; i++) if(_dat[i] != test._dat[i]) return false;
			if(_si32.Count != test._si32.Count) return false;
			for(var i = 0; i < _si32.Count; i++) if(_si32[i] != test._si32[i]) return false;
			if(_si64.Count != test._si64.Count) return false;
			for(var i = 0; i < _si64.Count; i++) if(_si64[i] != test._si64[i]) return false;
			if(_ui32.Count != test._ui32.Count) return false;
			for(var i = 0; i < _ui32.Count; i++) if(_ui32[i] != test._ui32[i]) return false;
			if(_ui64.Count != test._ui64.Count) return false;
			for(var i = 0; i < _ui64.Count; i++) if(_ui64[i] != test._ui64[i]) return false;
			if(_dec.Count != test._dec.Count) return false;
			for(var i = 0; i < _dec.Count; i++) if(_dec[i] != test._dec[i]) return false;
			if(_chr.Count != test._chr.Count) return false;
			for(var i = 0; i < _chr.Count; i++) if(_chr[i] != test._chr[i]) return false;
			if(_enu.Count != test._enu.Count) return false;
			for(var i = 0; i < _enu.Count; i++) if(_enu[i] != test._enu[i]) return false;
			if(_f32.Count != test._f32.Count) return false;
			for(var i = 0; i < _f32.Count; i++) if(_f32[i] != test._f32[i]) return false;
			if(_f64.Count != test._f64.Count) return false;
			for(var i = 0; i < _f64.Count; i++) if(_f64[i] != test._f64[i]) return false;
			return true;
		}
		public override void Get(FieldDescriptor ds_, IDataReader dr_)
		{
			switch( ds_.Pos )
			{
				case 0: _i32.Add(dr_.AsInt()); break;
				case 1: _i64.Add(dr_.AsLong()); break;
				case 2: _str.Add(dr_.AsString()); break;
				case 3: _bts.Add(dr_.AsBytes()); break;
				case 4: _bln.Add(dr_.AsBool()); break;
				case 5: _flt.Add(dr_.AsFloat()); break;
				case 6: _cur.Add(dr_.AsCurrency()); break;
				case 7: _dbl.Add(dr_.AsDouble()); break;
				case 8: _dat.Add(dr_.AsDate()); break;
				case 9: _si32.Add(dr_.AsSi32()); break;
				case 10: _si64.Add(dr_.AsSi64()); break;
				case 11: _ui32.Add((uint)dr_.AsInt()); break;
				case 12: _ui64.Add((ulong)dr_.AsLong()); break;
				case 13: _dec.Add(dr_.AsDecimal()); break;
				case 14: _chr.Add(dr_.AsChar()); break;
				case 15: _enu.Add((Colors)dr_.AsEnum(EnumDescriptors.Colors)); break;
				case 16: _f32.Add((uint)dr_.AsBit32()); break;
				case 17: _f64.Add((ulong)dr_.AsBit64()); break;
			}
		}
		public override int GetSerializedSize()
		{
			var _gss_ = 0;
			var count_ = _i32.Count;
			if(count_ > 0) { _gss_ += count_; foreach(var item in _i32.Items) _gss_ += Pbs.i32(item); }
			if((count_ = _i64.Count) > 0) { _gss_ += count_; foreach(var item in _i64.Items) _gss_ += Pbs.i64(item); }
			if((count_ = _str.Count) > 0) { _gss_ += count_; foreach(var item in _str.Items) _gss_ += Pbs.str(item); }
			if((count_ = _bts.Count) > 0) { _gss_ += count_; foreach(var item in _bts.Items) _gss_ += Pbs.bts(item); }
			if((count_ = _bln.Count) > 0) { _gss_ += 2*count_; }
			if((count_ = _flt.Count) > 0) { _gss_ += 5*count_; }
			if((count_ = _cur.Count) > 0) { _gss_ += count_; foreach(var item in _cur.Items) _gss_ += Pbs.cur(item); }
			if((count_ = _dbl.Count) > 0) { _gss_ += 1 + Pbs.szPfx(8*count_); }
			if((count_ = _dat.Count) > 0) { _gss_ += count_; foreach(var item in _dat.Items) _gss_ += Pbs.dat(item); }
			if((count_ = _si32.Count) > 0) { _gss_ += 1; _memoized_size = _gss_; foreach(var item in _si32.Items) _gss_ += Pbs.si32(item); _gss_ += Pbs.i32(_gss_-_memoized_size); }
			if((count_ = _si64.Count) > 0) { _gss_ += count_; foreach(var item in _si64.Items) _gss_ += Pbs.si64(item); }
			if((count_ = _ui32.Count) > 0) { _gss_ += count_; foreach(var item in _ui32.Items) _gss_ += Pbs.i32((int)item); }
			if((count_ = _ui64.Count) > 0) { _gss_ += count_; foreach(var item in _ui64.Items) _gss_ += Pbs.i64((long)item); }
			if((count_ = _dec.Count) > 0) { _gss_ += count_; foreach(var item in _dec.Items) _gss_ += Pbs.dec(item); }
			if((count_ = _chr.Count) > 0) { _gss_ += count_; foreach(var item in _chr.Items) _gss_ += Pbs.chr(item); }
			if((count_ = _enu.Count) > 0) { _gss_ += 2 + Pbs.szPfx(count_); }
			if((count_ = _f32.Count) > 0) { _gss_ += 6*count_; }
			if((count_ = _f64.Count) > 0) { _gss_ += 10*count_; }
			return _memoized_size = _gss_;
		}
		public override void Put(IDataWriter wr_)
		{
			var fs_ = Descriptor.Fields;
			if(_i32.Count > 0) wr_.AsRepeated(fs_[0], _i32.Items);
			if(_i64.Count > 0) wr_.AsRepeated(fs_[1], _i64.Items);
			if(_str.Count > 0) wr_.AsRepeated(fs_[2], _str.Items);
			if(_bts.Count > 0) wr_.AsRepeated(fs_[3], _bts.Items);
			if(_bln.Count > 0) wr_.AsRepeated(fs_[4], _bln.Items);
			if(_flt.Count > 0) wr_.AsRepeated(fs_[5], _flt.Items);
			if(_cur.Count > 0) wr_.AsRepeated(fs_[6], _cur.Items);
			if(_dbl.Count > 0) wr_.AsRepeated(fs_[7], _dbl.Items);
			if(_dat.Count > 0) wr_.AsRepeated(fs_[8], _dat.Items);
			if(_si32.Count > 0) wr_.AsRepeated(fs_[9], _si32.Items);
			if(_si64.Count > 0) wr_.AsRepeated(fs_[10], _si64.Items);
			if(_ui32.Count > 0) wr_.AsRepeated(fs_[11], _ui32.Items);
			if(_ui64.Count > 0) wr_.AsRepeated(fs_[12], _ui64.Items);
			if(_dec.Count > 0) wr_.AsRepeated(fs_[13], _dec.Items);
			if(_chr.Count > 0) wr_.AsRepeated(fs_[14], _chr.Items);
			if(_enu.Count > 0) wr_.AsRepeated(fs_[15], _enu.Items);
			if(_f32.Count > 0) wr_.AsRepeated(fs_[16], _f32.Items);
			if(_f64.Count > 0) wr_.AsRepeated(fs_[17], _f64.Items);
		}
		#endregion
	}
	
	public sealed partial class Noah : Message
	{
		public override MessageDescriptor GetDescriptor() { return Descriptor; }
		public static readonly MessageDescriptor Descriptor = new MessageDescriptor_20( "Noah", Pbs.iNone,
			new Noah(),
			new FieldDescriptor("Vals", 10, 15, OptFields.Descriptor),
			new FieldDescriptor("Reps", 18, 15, RepFields.Descriptor),
			new FieldDescriptor("Lots", 26, 79, OptFields.Descriptor),
			new FieldDescriptor("Tags", 34, 133)
		);
		
		// optional OptFields Vals = 1;
		public OptFields Vals { get; set; }
		// optional RepFields Reps = 2;
		public RepFields Reps { get; set; }
		// repeated OptFields Lots = 3;
		public OptFields[] Lots { get { return _lots.Items; } set { _lots.Items = value; } }
		// required string Tags = 4;
		public string Tags { get; set; }
		
		#region message fields
		public void ClearVals() { Vals = null; }
		public bool HasVals { get { return Vals != null; } }
		public void ClearReps() { Reps = null; }
		public bool HasReps { get { return Reps != null; } }
		private Repeated<OptFields> _lots;
		public int LotsCount { get { return _lots.Count; } }
		public void ClearLots() { _lots.Clear(); }
		public OptFields AddLots(OptFields i) { return _lots.Add(i); }
		public OptFields GetLots(int i) { return _lots[i]; }
		public void ClearTags() { Tags = null; }
		public bool HasTags { get { return Tags != null; } }
		#endregion
		
		#region message methods
		public override Message New() { return new Noah(); }
		public override void Clear()
		{
			_memoized_size = 0;
			Vals = null;
			Reps = null;
			_lots.Clear();
			Tags = null;
		}
		public override int GetHashCode() { return base.GetHashCode(); }
		public override bool Equals(object msg)
		{
			var test = msg as Noah;
			if(test==null) return false;
			if((Vals==null&&test.Vals!=null) || !Vals.Equals(test.Vals)) return false;
			if((Reps==null&&test.Reps!=null) || !Reps.Equals(test.Reps)) return false;
			if(_lots.Count != test._lots.Count) return false;
			for(var i = 0; i < _lots.Count; i++) if((_lots[i]==null&&test._lots[i]!=null) || !_lots[i].Equals(test._lots[i])) return false;
			if(Tags != test.Tags) return false;
			return true;
		}
		public override bool IsInitialized()
		{
			if( !HasTags ) return false;
			return true;
		}
		public override void Get(FieldDescriptor ds_, IDataReader dr_)
		{
			switch( ds_.Pos )
			{
				case 0: dr_.AsMessage( Vals??(Vals = new OptFields())); break;
				case 1: dr_.AsMessage( Reps??(Reps = new RepFields())); break;
				case 2: { var _f2_= new OptFields(); dr_.AsMessage(_f2_); _lots.Add(_f2_); } break;
				case 3: Tags = dr_.AsString(); break;
			}
		}
		public override int GetSerializedSize()
		{
			var _gss_ = 0;
			if(HasVals) _gss_ += 1 + Pbs.msg(Vals);
			if(HasReps) _gss_ += 1 + Pbs.msg(Reps);
			var count_ = _lots.Count;
			if(count_ > 0) { _gss_ += count_; foreach(var item in _lots.Items) _gss_ += Pbs.msg(item); }
			if(HasTags) _gss_ += 1 + Pbs.str(Tags);
			return _memoized_size = _gss_;
		}
		public override void Put(IDataWriter wr_)
		{
			var fs_ = Descriptor.Fields;
			if(HasVals) wr_.AsMessage(fs_[0], Vals);
			if(HasReps) wr_.AsMessage(fs_[1], Reps);
			if(_lots.Count > 0) wr_.AsRepeated(fs_[2], _lots.Items);
			if(HasTags) wr_.AsString(fs_[3], Tags);
		}
		#endregion
	}
}